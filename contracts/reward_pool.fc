;; DAUR Reward Pool Contract
;; Manages reward distribution to compute nodes

#include "stdlib.fc";

;; Storage:
;; admin_address: slice
;; total_pool: int (in nanotons)
;; rewards_dict: dict<node_id, pending_rewards>

(slice, int, cell) load_data() inline {
    slice ds = get_data().begin_parse();
    return (
        ds~load_msg_addr(),
        ds~load_coins(),
        ds~load_dict()
    );
}

() save_data(slice admin, int total_pool, cell rewards) impure inline {
    set_data(
        begin_cell()
            .store_slice(admin)
            .store_coins(total_pool)
            .store_dict(rewards)
        .end_cell()
    );
}

;; Add rewards for a node
() add_reward(int node_id, int amount) impure {
    (slice admin, int total_pool, cell rewards) = load_data();
    
    ;; Get current pending rewards
    (slice current_rewards, int found?) = rewards.udict_get?(256, node_id);
    int pending = found? ? current_rewards~load_coins() : 0;
    
    ;; Add new rewards
    pending += amount;
    
    ;; Update dictionary
    rewards~udict_set(256, node_id, begin_cell().store_coins(pending).end_cell().begin_parse());
    
    save_data(admin, total_pool, rewards);
}

;; Claim rewards
() claim_rewards(int node_id, slice recipient) impure {
    (slice admin, int total_pool, cell rewards) = load_data();
    
    (slice current_rewards, int found?) = rewards.udict_get?(256, node_id);
    throw_unless(404, found?);
    
    int amount = current_rewards~load_coins();
    throw_unless(405, amount > 0);
    throw_unless(406, total_pool >= amount);
    
    ;; Send rewards
    var msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(recipient)
        .store_coins(amount)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
    .end_cell();
    
    send_raw_message(msg, 1);
    
    ;; Update pool and clear pending
    total_pool -= amount;
    rewards~udict_delete?(256, node_id);
    
    save_data(admin, total_pool, rewards);
}

() recv_internal(int msg_value, cell in_msg_full, slice in_msg_body) impure {
    ;; Accept deposits to pool
    if (in_msg_body.slice_empty?()) {
        (slice admin, int total_pool, cell rewards) = load_data();
        total_pool += msg_value;
        save_data(admin, total_pool, rewards);
        return ();
    }
    
    int op = in_msg_body~load_uint(32);
    
    if (op == 1) {  ;; add_reward
        int node_id = in_msg_body~load_uint(256);
        int amount = in_msg_body~load_coins();
        add_reward(node_id, amount);
        return ();
    }
    
    if (op == 2) {  ;; claim_rewards
        int node_id = in_msg_body~load_uint(256);
        slice recipient = in_msg_body~load_msg_addr();
        claim_rewards(node_id, recipient);
        return ();
    }
}

;; Get methods
int get_pending_rewards(int node_id) method_id {
    (slice admin, int total_pool, cell rewards) = load_data();
    (slice current_rewards, int found?) = rewards.udict_get?(256, node_id);
    
    if (found?) {
        return current_rewards~load_coins();
    }
    
    return 0;
}

int get_total_pool() method_id {
    (slice admin, int total_pool, cell rewards) = load_data();
    return total_pool;
}

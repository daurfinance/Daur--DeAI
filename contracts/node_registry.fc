;; DAUR Node Registry Contract
;; Manages registration and tracking of compute nodes

#include "stdlib.fc";

;; Storage structure:
;; nodes_dict: dict<node_id, node_info>
;; total_nodes: int
;; admin_address: slice

(slice, int, cell) load_data() inline {
    slice ds = get_data().begin_parse();
    return (
        ds~load_msg_addr(),  ;; admin_address
        ds~load_uint(32),    ;; total_nodes
        ds~load_dict()       ;; nodes_dict
    );
}

() save_data(slice admin_address, int total_nodes, cell nodes_dict) impure inline {
    set_data(
        begin_cell()
            .store_slice(admin_address)
            .store_uint(total_nodes, 32)
            .store_dict(nodes_dict)
        .end_cell()
    );
}

;; Register new node
() register_node(
    int node_id,
    slice owner_address,
    int cpu_cores,
    int ram_mb,
    int gpu_capability
) impure {
    (slice admin, int total_nodes, cell nodes) = load_data();
    
    ;; Create node info
    cell node_info = begin_cell()
        .store_slice(owner_address)
        .store_uint(cpu_cores, 8)
        .store_uint(ram_mb, 32)
        .store_uint(gpu_capability, 8)
        .store_uint(now(), 32)  ;; registration_time
        .store_uint(0, 64)      ;; total_tasks_completed
        .store_uint(0, 128)     ;; total_rewards_earned
        .store_uint(1, 1)       ;; is_active
    .end_cell();
    
    ;; Add to dictionary
    nodes~udict_set(256, node_id, node_info.begin_parse());
    total_nodes += 1;
    
    save_data(admin, total_nodes, nodes);
}

;; Update node statistics
() update_node_stats(
    int node_id,
    int tasks_completed,
    int rewards_earned
) impure {
    (slice admin, int total_nodes, cell nodes) = load_data();
    
    (slice node_info, int found?) = nodes.udict_get?(256, node_id);
    throw_unless(404, found?);
    
    ;; Parse existing data
    slice owner = node_info~load_msg_addr();
    int cpu_cores = node_info~load_uint(8);
    int ram_mb = node_info~load_uint(32);
    int gpu_capability = node_info~load_uint(8);
    int reg_time = node_info~load_uint(32);
    int total_tasks = node_info~load_uint(64);
    int total_rewards = node_info~load_uint(128);
    int is_active = node_info~load_uint(1);
    
    ;; Update stats
    total_tasks += tasks_completed;
    total_rewards += rewards_earned;
    
    ;; Save updated info
    cell updated_info = begin_cell()
        .store_slice(owner)
        .store_uint(cpu_cores, 8)
        .store_uint(ram_mb, 32)
        .store_uint(gpu_capability, 8)
        .store_uint(reg_time, 32)
        .store_uint(total_tasks, 64)
        .store_uint(total_rewards, 128)
        .store_uint(is_active, 1)
    .end_cell();
    
    nodes~udict_set(256, node_id, updated_info.begin_parse());
    save_data(admin, total_nodes, nodes);
}

;; Deactivate node
() deactivate_node(int node_id) impure {
    (slice admin, int total_nodes, cell nodes) = load_data();
    
    (slice node_info, int found?) = nodes.udict_get?(256, node_id);
    throw_unless(404, found?);
    
    ;; Parse and update
    slice owner = node_info~load_msg_addr();
    int cpu_cores = node_info~load_uint(8);
    int ram_mb = node_info~load_uint(32);
    int gpu_capability = node_info~load_uint(8);
    int reg_time = node_info~load_uint(32);
    int total_tasks = node_info~load_uint(64);
    int total_rewards = node_info~load_uint(128);
    
    cell updated_info = begin_cell()
        .store_slice(owner)
        .store_uint(cpu_cores, 8)
        .store_uint(ram_mb, 32)
        .store_uint(gpu_capability, 8)
        .store_uint(reg_time, 32)
        .store_uint(total_tasks, 64)
        .store_uint(total_rewards, 128)
        .store_uint(0, 1)  ;; is_active = false
    .end_cell();
    
    nodes~udict_set(256, node_id, updated_info.begin_parse());
    save_data(admin, total_nodes, nodes);
}

() recv_internal(int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        return ();
    }
    
    int op = in_msg_body~load_uint(32);
    
    if (op == 1) {  ;; register_node
        int node_id = in_msg_body~load_uint(256);
        slice owner = in_msg_body~load_msg_addr();
        int cpu_cores = in_msg_body~load_uint(8);
        int ram_mb = in_msg_body~load_uint(32);
        int gpu_capability = in_msg_body~load_uint(8);
        
        register_node(node_id, owner, cpu_cores, ram_mb, gpu_capability);
        return ();
    }
    
    if (op == 2) {  ;; update_stats
        int node_id = in_msg_body~load_uint(256);
        int tasks = in_msg_body~load_uint(64);
        int rewards = in_msg_body~load_uint(128);
        
        update_node_stats(node_id, tasks, rewards);
        return ();
    }
    
    if (op == 3) {  ;; deactivate
        int node_id = in_msg_body~load_uint(256);
        deactivate_node(node_id);
        return ();
    }
}

;; Get methods
(int, cell) get_node_info(int node_id) method_id {
    (slice admin, int total_nodes, cell nodes) = load_data();
    (slice node_info, int found?) = nodes.udict_get?(256, node_id);
    
    if (found?) {
        return (found?, begin_cell().store_slice(node_info).end_cell());
    }
    
    return (0, begin_cell().end_cell());
}

int get_total_nodes() method_id {
    (slice admin, int total_nodes, cell nodes) = load_data();
    return total_nodes;
}

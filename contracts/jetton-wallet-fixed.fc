;; DAUR Token Jetton Wallet Contract - Полнофункциональная реализация
;; Смарт-контракт кошелька для токенов DAUR на блокчейне TON

#include "imports/stdlib.fc";

;; Константы
const int min_tons_for_storage = 10000000; ;; 0.01 TON
const int gas_consumption = 15000000; ;; 0.015 TON

;; Операции
const int op::transfer = 0xf8a7ea5;
const int op::transfer_notification = 0x7362d09c;
const int op::internal_transfer = 0x178d4519;
const int op::excesses = 0xd53276db;
const int op::burn = 0x595f07bc;
const int op::burn_notification = 0x7bdd97de;

;; Ошибки
const int error::not_owner = 705;
const int error::not_enough_tons = 706;
const int error::not_enough_gas = 707;
const int error::not_valid_wallet = 708;
const int error::wrong_workchain = 709;
const int error::balance_error = 710;

;; Хранилище данных
;; balance:Coins owner_address:MsgAddress jetton_master_address:MsgAddress jetton_wallet_code:^Cell
(int, slice, slice, cell) load_data() inline {
    slice ds = get_data().begin_parse();
    return (
        ds~load_coins(), ;; balance
        ds~load_msg_addr(), ;; owner_address
        ds~load_msg_addr(), ;; jetton_master_address
        ds~load_ref() ;; jetton_wallet_code
    );
}

() save_data(int balance, slice owner_address, slice jetton_master_address, cell jetton_wallet_code) impure inline {
    set_data(begin_cell()
        .store_coins(balance)
        .store_slice(owner_address)
        .store_slice(jetton_master_address)
        .store_ref(jetton_wallet_code)
        .end_cell());
}

;; Расчет адреса кошелька
slice calculate_jetton_wallet_address(slice owner_address, slice jetton_master_address, cell jetton_wallet_code) inline {
    cell state_init = begin_cell()
        .store_uint(0, 2)
        .store_dict(jetton_wallet_code)
        .store_dict(begin_cell()
            .store_coins(0)
            .store_slice(owner_address)
            .store_slice(jetton_master_address)
            .store_ref(jetton_wallet_code)
            .end_cell())
        .store_uint(0, 1)
        .end_cell();
    
    return begin_cell()
        .store_uint(4, 3)
        .store_int(0, 8)
        .store_uint(cell_hash(state_init), 256)
        .end_cell()
        .begin_parse();
}

;; Отправка токенов
() send_tokens(slice to_address, slice jetton_master_address, int jetton_amount, int ton_amount, slice sender_address, int query_id, int forward_ton_amount, slice forward_payload, cell jetton_wallet_code) impure {
    slice to_wallet_address = calculate_jetton_wallet_address(to_address, jetton_master_address, jetton_wallet_code);
    
    var msg_body = begin_cell()
        .store_uint(op::internal_transfer, 32)
        .store_uint(query_id, 64)
        .store_coins(jetton_amount)
        .store_slice(sender_address)
        .store_slice(sender_address) ;; response_address
        .store_coins(forward_ton_amount)
        .store_slice(forward_payload)
        .end_cell();
    
    var msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(to_wallet_address)
        .store_coins(ton_amount)
        .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_ref(msg_body);
    
    send_raw_message(msg.end_cell(), 1); ;; pay transfer fees separately, revert on errors
}

;; Основная функция получения сообщений
() recv_internal(int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) { ;; ignore empty messages
        return ();
    }
    
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    
    if (flags & 1) { ;; ignore all bounced messages
        return ();
    }
    
    slice sender_address = cs~load_msg_addr();
    
    (int balance, slice owner_address, slice jetton_master_address, cell jetton_wallet_code) = load_data();
    
    int op = in_msg_body~load_uint(32);
    int query_id = in_msg_body~load_uint(64);
    
    if (op == op::transfer) { ;; outgoing transfer
        throw_unless(error::not_owner, equal_slices(sender_address, owner_address));
        
        int jetton_amount = in_msg_body~load_coins();
        slice to_address = in_msg_body~load_msg_addr();
        slice response_address = in_msg_body~load_msg_addr();
        cell custom_payload = in_msg_body~load_dict();
        int forward_ton_amount = in_msg_body~load_coins();
        slice forward_payload = in_msg_body;
        
        ;; Проверка баланса
        throw_unless(error::balance_error, balance >= jetton_amount);
        
        ;; Проверка достаточности TON для газа
        int fwd_fee = forward_ton_amount;
        if (forward_ton_amount) {
            fwd_fee += fwd_fee / 3; ;; добавляем 33% на комиссии
        }
        
        throw_unless(error::not_enough_tons, msg_value > fwd_fee + gas_consumption + min_tons_for_storage);
        
        ;; Уменьшение баланса
        balance -= jetton_amount;
        save_data(balance, owner_address, jetton_master_address, jetton_wallet_code);
        
        ;; Отправка токенов
        send_tokens(to_address, jetton_master_address, jetton_amount, fwd_fee + gas_consumption, owner_address, query_id, forward_ton_amount, forward_payload, jetton_wallet_code);
        
        ;; Отправка излишков обратно
        if (msg_value > fwd_fee + gas_consumption + min_tons_for_storage) {
            var msg = begin_cell()
                .store_uint(0x10, 6) ;; nobounce
                .store_slice(response_address)
                .store_coins(0)
                .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
                .store_uint(op::excesses, 32)
                .store_uint(query_id, 64);
            send_raw_message(msg.end_cell(), 64); ;; carry all the remaining value
        }
        
        return ();
    }
    
    if (op == op::internal_transfer) { ;; incoming transfer
        int jetton_amount = in_msg_body~load_coins();
        slice from_address = in_msg_body~load_msg_addr();
        slice response_address = in_msg_body~load_msg_addr();
        int forward_ton_amount = in_msg_body~load_coins();
        slice forward_payload = in_msg_body;
        
        ;; Проверка, что сообщение пришло от правильного кошелька
        slice expected_wallet = calculate_jetton_wallet_address(from_address, jetton_master_address, jetton_wallet_code);
        throw_unless(error::not_valid_wallet, equal_slices(sender_address, expected_wallet));
        
        ;; Увеличение баланса
        balance += jetton_amount;
        save_data(balance, owner_address, jetton_master_address, jetton_wallet_code);
        
        ;; Отправка уведомления владельцу
        if (forward_ton_amount) {
            var msg_body = begin_cell()
                .store_uint(op::transfer_notification, 32)
                .store_uint(query_id, 64)
                .store_coins(jetton_amount)
                .store_slice(from_address)
                .store_slice(forward_payload)
                .end_cell();
            
            var msg = begin_cell()
                .store_uint(0x10, 6) ;; nobounce
                .store_slice(owner_address)
                .store_coins(forward_ton_amount)
                .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)
                .store_ref(msg_body);
            send_raw_message(msg.end_cell(), 1);
        }
        
        ;; Отправка излишков обратно
        if (~ null?(response_address)) {
            var msg = begin_cell()
                .store_uint(0x10, 6) ;; nobounce
                .store_slice(response_address)
                .store_coins(0)
                .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
                .store_uint(op::excesses, 32)
                .store_uint(query_id, 64);
            send_raw_message(msg.end_cell(), 64); ;; carry all the remaining value
        }
        
        return ();
    }
    
    if (op == op::burn) { ;; burn tokens
        throw_unless(error::not_owner, equal_slices(sender_address, owner_address));
        
        int jetton_amount = in_msg_body~load_coins();
        slice response_address = in_msg_body~load_msg_addr();
        cell custom_payload = in_msg_body~load_dict();
        
        ;; Проверка баланса
        throw_unless(error::balance_error, balance >= jetton_amount);
        throw_unless(error::not_enough_tons, msg_value > gas_consumption + min_tons_for_storage);
        
        ;; Уменьшение баланса
        balance -= jetton_amount;
        save_data(balance, owner_address, jetton_master_address, jetton_wallet_code);
        
        ;; Отправка уведомления о сжигании мастер-контракту
        var msg_body = begin_cell()
            .store_uint(op::burn_notification, 32)
            .store_uint(query_id, 64)
            .store_coins(jetton_amount)
            .store_slice(owner_address)
            .store_slice(response_address)
            .end_cell();
        
        var msg = begin_cell()
            .store_uint(0x18, 6)
            .store_slice(jetton_master_address)
            .store_coins(0)
            .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)
            .store_ref(msg_body);
        send_raw_message(msg.end_cell(), 64); ;; carry all the remaining value
        
        return ();
    }
    
    throw(0xffff);
}

;; Get методы
(int, slice, slice, cell) get_wallet_data() method_id {
    return load_data();
}

int get_balance() method_id {
    (int balance, slice owner_address, slice jetton_master_address, cell jetton_wallet_code) = load_data();
    return balance;
}

slice get_owner() method_id {
    (int balance, slice owner_address, slice jetton_master_address, cell jetton_wallet_code) = load_data();
    return owner_address;
}

slice get_jetton_master() method_id {
    (int balance, slice owner_address, slice jetton_master_address, cell jetton_wallet_code) = load_data();
    return jetton_master_address;
}

# Техническая спецификация Daur-AI

**Версия:** 1.0
**Дата:** 1 декабря 2025 г.
**Автор:** Дауиржан Нуридинулы

---

## 1. Введение

### 1.1. Назначение документа

Настоящий документ содержит подробную техническую спецификацию децентрализованной сети искусственного интеллекта Daur-AI. В нем описываются архитектура системы, основные компоненты, протоколы взаимодействия, алгоритмы и технологии, используемые для реализации проекта.

### 1.2. Обзор проекта

Daur-AI — это децентрализованная вычислительная сеть, построенная на блокчейне TON, которая использует неиспользуемые ресурсы смартфонов для выполнения задач искусственного интеллекта. Проект основан на концепции **реверсивного ИИ** и консенсусе **Proof of Useful Work (PoUW)**, что позволяет эффективно распределять и выполнять сложные вычислительные задачи.

### 1.3. Ключевые цели

- **Демократизация доступа к ИИ:** Предоставить разработчикам и компаниям доступ к мощным вычислительным ресурсам по низкой цене.
- **Эффективное использование ресурсов:** Задействовать миллиарды простаивающих смартфонов в качестве узлов глобальной вычислительной сети.
- **Обеспечение конфиденциальности:** Реализовать механизмы для выполнения вычислений без раскрытия конфиденциальных данных.
- **Создание новой экономики:** Позволить владельцам смартфонов монетизировать свои устройства, участвуя в решении задач ИИ.

## 2. Архитектура системы

### 2.1. Высокоуровневая архитектура

Система Daur-AI состоит из четырех основных уровней:

1.  **Уровень приложений:** Пользовательские интерфейсы, API и SDK для взаимодействия с сетью.
2.  **Уровень управления:** Компоненты MainAI и Оркестратор, отвечающие за декомпозицию, планирование и распределение задач.
3.  **Уровень выполнения:** Децентрализованная сеть мобильных узлов (смартфонов), выполняющих подзадачи.
4.  **Уровень консенсуса и расчетов:** Блокчейн TON, обеспечивающий регистрацию задач, проверку результатов и распределение вознаграждений.

*(Ссылка на диаграмму архитектуры будет добавлена после ее создания)*

### 2.2. Компоненты системы

| Компонент | Описание | Ключевые технологии |
| :--- | :--- | :--- |
| **MainAI** | Стратегический ИИ, который анализирует, декомпозирует и планирует выполнение задач. | Python, PyTorch, TensorFlow, FastAPI |
| **Оркестратор** | Управляет жизненным циклом задач, распределяет подзадачи между узлами и отслеживает их выполнение. | Go, gRPC, Redis, PostgreSQL |
| **Мобильный узел** | Клиентское приложение для смартфона, которое выполняет подзадачи и управляет локальными ресурсами. | React Native, TensorFlow Lite, Core ML |
| **Сеть оракулов** | Специализированные узлы, которые проверяют результаты вычислений для обеспечения качества и безопасности. | Пользовательские алгоритмы валидации, консенсус Tendermint |
| **Блокчейн TON** | Инфраструктура для смарт-контрактов, хранения метаданных и выполнения транзакций. | FunC, TON Virtual Machine (TVM) |

### 2.3. Технологический стек

- **Бэкенд:** Go, Python
- **Фреймворки ИИ:** PyTorch, TensorFlow
- **Мобильная разработка:** React Native
- **Базы данных:** PostgreSQL, Redis
- **Блокчейн:** TON (The Open Network)
- **Язык смарт-контрактов:** FunC
- **Хранилище файлов:** IPFS
- **Контейнеризация:** Docker, Kubernetes

## 3. Ключевые концепции

### 3.1. Реверсивный ИИ

#### 3.1.1. Принцип работы

Реверсивный ИИ начинает с конечной цели и работает в обратном направлении для построения оптимального плана решения. MainAI анализирует задачу и создает **направленный ациклический граф (DAG)**, где каждый узел представляет собой подзадачу, а ребра — зависимости между ними.

#### 3.1.2. Алгоритм декомпозиции

1.  **Анализ задачи:** MainAI использует предобученные модели для семантического анализа задачи и определения ее типа (например, обработка текста, классификация изображений).
2.  **Построение графа:** На основе анализа создается граф зависимостей. Например, для задачи перевода текста граф может состоять из узлов для перевода отдельных предложений и узлов для восстановления контекста.
3.  **Оценка ресурсов:** Для каждого узла графа оцениваются необходимые ресурсы (CPU, GPU, RAM, время).
4.  **Оптимизация графа:** Граф оптимизируется для минимизации зависимостей и максимизации параллелизма.

### 3.2. Proof of Useful Work (PoUW)

#### 3.2.1. Механизм консенсуса

Вместо решения бессмысленных криптографических головоломок, узлы в сети Daur-AI выполняют полезную работу — решают подзадачи ИИ. Результат выполнения подзадачи служит доказательством работы.

#### 3.2.2. Структура вознаграждения

Вознаграждение узла зависит от следующих факторов:

- **Сложность подзадачи:** Оценивается на этапе декомпозиции.
- **Качество выполнения:** Проверяется сетью оракулов.
- **Репутация узла:** Узлы с высокой репутацией получают приоритет и более высокое вознаграждение.
- **Стейкинг:** Узлы, застейкавшие токены DAUR, получают мультипликатор к вознаграждению.

## 4. Управление данными и моделями

### 4.1. Стратегия хранения

- **Блокчейн TON:** Хранит хеши данных, метаданные задач, результаты (или их хеши), записи о репутации и транзакции.
- **IPFS:** Используется для хранения больших файлов: моделей ИИ, наборов данных для обучения и результатов вычислений. Ссылки на файлы в IPFS (CID) хранятся в блокчейне.
- **Локальное кэширование:** Мобильные узлы кэшируют часто используемые модели и данные для ускорения выполнения задач.

### 4.2. Безопасность и конфиденциальность

- **Гомоморфное шифрование:** Для выполнения вычислений над зашифрованными данными (находится в стадии исследования и разработки).
- **Федеративное обучение:** Модели обучаются на локальных данных без их передачи на сервер.
- **Дифференциальная приватность:** К обновлениям моделей (градиентам) добавляется шум для защиты конфиденциальности индивидуальных данных.
- **Безопасные анклавы (Secure Enclaves):** На поддерживаемых устройствах вычисления производятся в изолированной среде (например, ARM TrustZone).

### 4.3. Обучение и версионирование моделей

#### 4.3.1. Процесс федеративного обучения

1.  **Инициализация:** MainAI рассылает глобальную модель на выбранные узлы.
2.  **Локальное обучение:** Каждый узел обучает модель на своих данных.
3.  **Отправка обновлений:** Узлы отправляют зашифрованные и анонимизированные обновления (градиенты) в MainAI.
4.  **Агрегация:** MainAI агрегирует обновления для улучшения глобальной модели.
5.  **Итерация:** Процесс повторяется до достижения целевой точности.

#### 4.3.2. Версионирование

- **Семантическое версионирование:** Модели версионируются по схеме `MAJOR.MINOR.PATCH`.
- **Реестр моделей:** В блокчейне ведется реестр доступных моделей с указанием их версий, хешей и совместимости.
- **Дифференциальные обновления:** Узлы загружают только изменения между версиями, а не всю модель целиком.

## 5. Интеграция с блокчейном TON

### 5.1. Смарт-контракты (FunC)

#### 5.1.1. TaskRegistry Contract

- **Состояние:** `task_id`, `owner`, `description_cid`, `reward`, `status`, `assigned_node`, `result_cid`.
- **Функции:** `create_task()`, `assign_task()`, `submit_result()`, `verify_result()`, `release_payment()`.

#### 5.1.2. DAUR Token Contract (Jetton)

- Стандартный контракт жетона TON для управления токеном DAUR.
- **Функции:** `transfer()`, `burn()`, `mint()` (ограниченный доступ).

#### 5.1.3. Reputation Contract

- **Состояние:** `node_address`, `reputation_score`, `completed_tasks`, `failed_tasks`.
- **Функции:** `update_reputation()`, `get_reputation()`.

#### 5.1.4. Governance Contract

- **Состояние:** `proposals`, `votes`.
- **Функции:** `create_proposal()`, `vote()`, `execute_proposal()`.

## 6. API и SDK

### 6.1. REST API

- **Эндпоинты:**
  - `POST /tasks` - Создание новой задачи.
  - `GET /tasks/{id}` - Получение статуса задачи.
  - `GET /tasks/{id}/result` - Получение результата задачи.
  - `GET /nodes` - Получение списка активных узлов.
- **Аутентификация:** API-ключи.

### 6.2. WebSocket API

- **События:** `task_updated`, `result_ready`, `node_online`.
- **Назначение:** Получение обновлений в реальном времени.

### 6.3. SDK

- **Python SDK:** Библиотека для удобного взаимодействия с API, отправки задач и получения результатов.
- **JavaScript SDK:** Для интеграции с веб-приложениями.

## 7. Жизненный цикл задачи

1.  **Отправка:** Пользователь через API или SDK отправляет задачу, указывая описание (CID файла в IPFS) и вознаграждение.
2.  **Регистрация:** Задача регистрируется в `TaskRegistry Contract`.
3.  **Декомпозиция:** MainAI получает уведомление о новой задаче, анализирует ее и создает DAG подзадач.
4.  **Аукцион:** Оркестратор объявляет аукцион на выполнение подзадач.
5.  **Назначение:** Узлы с подходящей репутацией и ресурсами делают ставки. Оркестратор выбирает исполнителей.
6.  **Выполнение:** Узел-исполнитель загружает модель и данные из IPFS, выполняет подзадачу и загружает результат в IPFS.
7.  **Верификация:** Узел-исполнитель отправляет CID результата в `TaskRegistry Contract`. Сеть оракулов проверяет результат.
8.  **Агрегация:** После выполнения всех подзадач MainAI агрегирует результаты.
9.  **Завершение:** Финальный результат записывается в блокчейн, и вознаграждение переводится исполнителям.

## 8. Глоссарий

- **DAG (Directed Acyclic Graph):** Направленный ациклический граф, используемый для представления зависимостей между подзадачами.
- **PoUW (Proof of Useful Work):** Алгоритм консенсуса, где доказательством работы служит выполнение полезных вычислений.
- **Федеративное обучение:** Метод машинного обучения, позволяющий обучать модели на децентрализованных данных.
- **Оркестратор:** Компонент, управляющий распределением и выполнением задач в сети.

---
